<!DOCTYPE html>
<html lang="en">
<head>
        <title>Parallel sorting via the linuxÂ commandline</title>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pure/0.6.0/pure-min.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pure/0.6.0/grids-responsive-min.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.4.0/css/font-awesome.min.css" />
        <link rel="stylesheet" href="./theme/css/main.css" />
</head>
<body>

    <div class="navigation pure-menu pure-menu-horizontal">
        <a href="./" class="pure-menu-heading  pure-menu-link">Slacy's Blog</a>
        <ul class="pure-menu-list">
            <li class="pure-menu-item"></li>

        </ul>
    </div>


<div class="page-container">
    <div class="entry-content">
        <div class="post-meta pure-g">
<div class="pure-u-3-4 meta-data">
    <a href="./category/general.html" class="category">General</a><br />

    <a class="author" href="./author/slacy.html">slacy</a>
    &mdash; <abbr title="2008-06-11T22:35:00-07:00">Wed 11 June 2008</abbr>
</div>        </div>
    </div>

    <div class="article-header-container">
        <div class="background-image-container">

            <div class="background-image-small">
                <div class="title-container">
                    <h1>Parallel sorting via the linux&nbsp;commandline</h1>
                </div>
            </div>
        </div>
    </div>

    <div class="entry-content">
        <p>In my <a href="http://slacy.com/blog/index.php/2008/06/10/unix-commandline-challenge/">previous
post</a>,
I challenged you to write a shell script that could grep a large file in&nbsp;parallel.</p>
<p>Several comments on that post mentioned that grep was very fast, and
that I/O is clearly the bottleneck, so parallelizing will be of very
little&nbsp;help.</p>
<p>With that in mind, I now challenge you to write a simple script to
parallelize sorting of a single large file. The file is generated by the
same <a href="http://slacy.com/blog/wp-content/randwords.pl">randwords.pl</a>
script, but this time,&nbsp;its:</p>
<div class="highlight"><pre><span></span># LC_ALL=C wc randwords 
  92995543   92995544 1069481984 randwords
</pre></div>


<p>92M lines, just over <span class="caps">1020MB</span> of random&nbsp;junk.</p>
<p>Since the perl &#8220;sharding&#8221; script didn&#8217;t work out too well, and since
I&#8217;ve learned to embrace mkfifo, and I&#8217;ve written a simple C++ helper
program I call &#8216;interleave&#8217;. The source&nbsp;is:</p>
<div class="highlight"><pre><span></span><span class="c1">// interleave.cc</span>
<span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">num_files</span> <span class="o">=</span> <span class="n">argc</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> 
  <span class="kt">FILE</span> <span class="o">*</span><span class="n">outs</span><span class="p">[</span><span class="n">num_files</span><span class="p">];</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">argc</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">outs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="s">&quot;a&quot;</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="c1">// Credits go to &#39;man getline&#39; for the guts of this...</span>
  <span class="kt">ssize_t</span> <span class="n">read</span><span class="p">;</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">line</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
  <span class="kt">size_t</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> 
  <span class="k">while</span> <span class="p">((</span><span class="n">read</span> <span class="o">=</span> <span class="n">getline</span><span class="p">(</span><span class="o">&amp;</span><span class="n">line</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">len</span><span class="p">,</span> <span class="n">stdin</span><span class="p">))</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// I&#39;m pretty sure that buffering here would make a huge difference in performance.</span>
    <span class="n">fwrite</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="n">read</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">outs</span><span class="p">[</span><span class="n">counter</span> <span class="o">%</span> <span class="n">num_files</span><span class="p">]);</span>
    <span class="n">counter</span><span class="o">++</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">line</span><span class="p">)</span>
    <span class="n">free</span><span class="p">(</span><span class="n">line</span><span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_files</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">fclose</span><span class="p">(</span><span class="n">outs</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span> 
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">EXIT_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>So, this will take an input file, and &#8220;interleave&#8221; the lines of the file
across an arbitrary set of output files. Its very similar to the
shard.pl, except that its C, so its moderately fast. (<span class="caps">NB</span>: Still lots of
room for improvement here, but it gets the job&nbsp;done.)</p>
<p>Once that was tested and working, I wrote a small wrapper script to
create some fifos, and spawn off a bunch of sort&nbsp;processes.</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="ch">#!/bin/bash</span>
<span class="c1"># psort.sh </span>
<span class="nv">NWAY</span><span class="o">=</span><span class="m">4</span>
<span class="nv">COUNTER</span><span class="o">=</span><span class="m">0</span>
<span class="k">until</span> <span class="o">[</span> <span class="nv">$COUNTER</span> -ge <span class="nv">$NWAY</span> <span class="o">]</span><span class="p">;</span> <span class="k">do</span>
mkfifo <span class="nv">$1</span>_chunk_<span class="nv">$COUNTER</span><span class="p">;</span>
<span class="nv">COUNTER</span><span class="o">=</span><span class="sb">`</span>expr <span class="nv">$COUNTER</span> + <span class="m">1</span><span class="sb">`</span>
<span class="k">done</span>
<span class="nb">echo</span> <span class="s2">&quot;interleaving&quot;</span> 
cat <span class="nv">$1</span> <span class="p">|</span> ./interleave <span class="nv">$1</span>_chunk_* <span class="p">&amp;</span>
<span class="k">for</span> file in <span class="nv">$1</span>_chunk_*<span class="p">;</span> <span class="k">do</span>
<span class="nb">echo</span> <span class="s2">&quot;sorting </span><span class="nv">$file</span><span class="s2"> in the background&quot;</span>
sort <span class="nv">$file</span> &gt; sorted.<span class="nv">$file</span> <span class="p">&amp;</span>
<span class="k">done</span>
<span class="c1"># Wait for backgrounded interleave &amp; sorts to finish up. </span>
<span class="nb">wait</span> 
<span class="nb">echo</span> <span class="s2">&quot;Merging&quot;</span> 
sort -m sorted.<span class="nv">$1</span>_chunk_*  &gt; result 
rm <span class="nv">$1</span>_chunk_* sorted.<span class="nv">$1</span>_chunk_*
</pre></div>
</td></tr></table>

<p>I&#8217;ve called this &#8216;psort.sh&#8217;. All we&#8217;re doing there is spawing an
interleave in the background, outputting to a series of named pipes, and
then sorting each of those pipes and storing them as a temporary file.
We then merge all the temporary files together to form the final results&nbsp;file.</p>
<p>How does it perform? Well, about 12.5% faster than a naive invocation of
&#8216;sort&#8217;. Here&#8217;s the&nbsp;proof:</p>
<div class="highlight"><pre><span></span># time ./psort.sh randwords 
Making fifo randwords_chunk_0;
Making fifo randwords_chunk_1;
Making fifo randwords_chunk_2;
Making fifo randwords_chunk_3;
splitting
sorting randwords_chunk_0 in the background
sorting randwords_chunk_1 in the background
sorting randwords_chunk_2 in the background
sorting randwords_chunk_3 in the background
Merging

real    3m34.493s
user    3m36.564s
sys     0m32.885s

# time sort randwords &gt; results.1proc
real    4m0.802s
user    3m27.967s
sys     0m14.958s
</pre></div>


<p>So, why only 12.5% faster? Well, 2 reasons that I can think&nbsp;of:</p>
<p>1. &#8220;interleave&#8221; was taking up about 20% of the <span class="caps">CPU</span> for the psort
invocation, and I believe it could be significantly optimized. I tried
invoking &#8216;split&#8217; in interleave.sh, and splitting out to a bunch of
fifos, but because of the linear nature of that, it didn&#8217;t have the same
level of parallelism that the interleave command&nbsp;enables.</p>
<p>2. The temporary sort includes 2 merge phases. First, each of the
parallel sorts has to merge its temporary files (in parallel!), and this
is extremely I/O intensive, and then the &#8220;sort -m&#8221; has to merge those
outputs, so there are 2 phases of merging, which takes away
significantly from the overall&nbsp;runtime.</p>
<p>If you&#8217;d like to help optimize interleave.cc, or to come up with a
better way to do this, feel free to leave a comment with your&nbsp;solution!</p>
    </div>

    <footer>
        <div class="pure-g post-footer">
            <div class="pure-u-1 pure-u-md-1-2">
                <div class="pure-g poster-info">
                    <div class="pure-u">
                        <a href="./author/slacy.html"><img src="https://slacy.github.io/blog/images/ygg.png" alt=""></a>
                    </div>
                    <div class="pure-u-3-4">
                        <h3 class="author-name"><a href="./author/slacy.html">slacy</a></h3>
                        <p class="author-description">
                                              
                        </p>
                    </div>
                </div>
            </div>



        </div>


    </footer>


</div>



    <footer class="index-footer">

        <a href="./" title="Slacy's Blog">Slacy's Blog</a>

    </footer>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-85612-4', 'auto');
      ga('send', 'pageview');

    </script>
</body>
</html>